#!/usr/bin/python

from datetime import datetime, timedelta
from logging.config import dictConfig
import StringIO
import argparse
import httplib
import logging
import json
import os
import socket
import urllib
import yaml

logging_config = dict(
  version = 1,
  formatters = {
    'f': {'format':
          '%(asctime)s %(module)s:%(lineno)s %(levelname)s: %(message)s'}
  },
  handlers = {
    'h': {'class': 'logging.StreamHandler',
          'formatter': 'f',
          'level': logging.DEBUG},
    'hF': {'class': 'logging.FileHandler',
           'filename': '/tmp/wamcstats.log',
           'formatter': 'f',
           'level': logging.DEBUG},
  },
  root = {
    'handlers': ['h', 'hF'],
    'level': logging.DEBUG,
  },
)


def curdir_realpath(path):
  return os.path.realpath(os.path.join(os.path.dirname(__file__), path))

CONFIG_FILE=curdir_realpath('wamcstats.yaml')
SECRET_CONFIG_FILE=curdir_realpath('wamcstats-secret.yaml')
TIMESTAMP_FILE="/tmp/wamcstats"

class Notifier:
  def __init__(self, args):
    self.dryrun = args.dryrun
    self.config = yaml.load(open(CONFIG_FILE))
    self.config['secrets'] = yaml.load(open(SECRET_CONFIG_FILE))

  def maybe_notify(self):
    output = StringIO.StringIO()
    print >>output, "Hello from", socket.gethostname(), "running WAMC!"
    print >>output, "Uptime is", uptime()
    if reboot_required_since() != None:
      print >>output, "WARNING: Reboot required for", \
        datetime.utcnow() - reboot_required_since()
    for relpath in self.config["monitored-partitions"]:
      path = os.path.join(os.path.dirname(CONFIG_FILE), relpath)
      print >>output, FSReport(path).report()
    if self._fs_with_warning():
      print >>output, "WARNING: Remaining disk space too low on", \
        self._fs_with_warning()

    print >>output

    print >>output, 'Load average:', os.getloadavg()

    print >>output

    try:
      sonarr_health = get_sonarr_health()
      print_sonarr_health(output, sonarr_health)
    except Exception, ex:
      print >>output, "Failed to get sonarr health:", ex

    notification_text = output.getvalue()

    logging.info('Notification text:\n%s', notification_text)

    if not self._should_notify():
      logging.info('Timestamp is too new')
      return
    self._mark_timestamp()
    logging.info('Should notify!')

    self._pushover_notify(notification_text)
    self._sendgrid_notify(notification_text)

  def _fs_with_warning(self):
    result = []
    for path in self.config["monitored-partitions"]:
      if FSReport(path).avail_fraction() < \
          self.config["minimal-free-space-fraction"]:
        result.append(path)
    return result

  def _should_notify(self):
    min_timestamp_age = self._heartbeat_hours()
    if self._fs_with_warning():
      min_timestamp_age = self._alert_hours()

    logging.info('Minimal timestamp age to notify: %s', min_timestamp_age)

    if self.dryrun:
      logging.info('Dry run mode, so notify anyway')
      return True

    return self._timestamp_age() > min_timestamp_age

  def _prev_timestamp(self):
    if os.path.isfile(TIMESTAMP_FILE):
      s = os.stat(TIMESTAMP_FILE)
      return datetime.utcfromtimestamp(s.st_mtime)
    else:
      return datetime(1970, 1, 1)

  def _timestamp_age(self):
    age = datetime.utcnow() - self._prev_timestamp()
    logging.info('Timestamp age: %s', age)
    return age

  def _heartbeat_hours(self):
    return timedelta(hours = int(self.config["heartbeat-hours"]))

  def _alert_hours(self):
    return timedelta(hours = int(self.config["alert-hours"]))

  def _mark_timestamp(self):
    if self.dryrun:
      logging.info('Dry run - not timestamping at %s', TIMESTAMP_FILE)
    try:
      os.utime(TIMESTAMP_FILE, None)
    except OSError:
      open(TIMESTAMP_FILE, 'a').close()

  def _sendgrid_notify(self, msg):
    if "sendgrid" not in self.config["secrets"]:
      logging.info("Sendgrid secrets not configured, skipping")
      return

    if self.dryrun:
      logging.info("DRY RUN: Would have sent sendgrid message")
      logging.info("Sendgrid config: %s", self.config["sendgrid"])
      logging.info("Message: %s", msg)
      return

    sendgrid_conf = self.config["secrets"]["sendgrid"]

    req = json.dumps({
      'personalizations': [
        {'to': [{'email': sendgrid_conf["to"]}]}
      ],
      'from': {'email': sendgrid_conf["from"]},
      'subject': 'Update from wamcstats',
      'content': [{"type": "text/plain", "value": msg}],
    })

    conn = httplib.HTTPSConnection('api.sendgrid.com:443')
    conn.request('POST', '/v3/mail/send', req, {
      "Authorization": "Bearer %s" % sendgrid_conf["api_key"],
      "Content-Type": "application/json",
    })

    r = conn.getresponse()

    if r.status >= 300 or r.status < 200:
      raise Exception("Sendgrid returned %d %s" % (r.status, r.reason))

  def _pushover_notify(self, msg):
    if "pushover" not in self.config["secrets"]:
      logging.info("Pushover secrets not configured, skipping")
      return

    if self.dryrun:
      logging.info("DRY RUN: Would have sent pushover message")
      logging.info("Pushover config: %s", self.config["pushover"])
      logging.info("Message: %s", msg)
      return

    conn = httplib.HTTPSConnection('api.pushover.net:443')
    conn.request('POST', '/1/messages',
      urllib.urlencode({
        'token': self.config["secrets"]["pushover"]["token"],
        'user': self.config["secrets"]["pushover"]["user"],
        'message': msg,
      }), { "Content-Type": "application/x-www-form-urlencoded" })

    r = conn.getresponse()

    if r.status != httplib.OK:
      raise Exception("Pushover returned %d %s" % (r.status, r.reason))

def uptime():
  with open('/proc/uptime', 'r') as f:
    uptime_seconds = float(f.readline().split()[0])
    return timedelta(seconds=uptime_seconds)

def reboot_required_since():
  try:
    s = os.stat('/var/run/reboot-required')
    return datetime.utcfromtimestamp(s.st_ctime)
  except OSError:
    return None

def print_sonarr_health(output_file, health):
  print >>output_file, 'Sonarr health:'
  if len(health) == 0:
    print >>output_file, "Healthy (no items)"
  for item in health:
    print >>output_file, item['type'] + ': ' + item['message']

def get_sonarr_health():
  try:
    api_key = yaml.load(open(SECRET_CONFIG_FILE))['sonarr']['api_key']
  except:
    raise Exception('%s does not define sonarr.api_key' % SECRET_CONFIG_FILE)
  sonarr_health_path = '/sonarr/api/health?apikey=' + api_key
  conn = httplib.HTTPConnection('localhost')
  conn.request('GET', sonarr_health_path)
  r = conn.getresponse()
  if r.status != httplib.OK:
    raise Exception('Sonarr health returned %d %s' % (r.status, r.reason))
  return json.load(r)


class FSReport:
  def __init__(self, path):
    self.path = path
    self.stat = os.statvfs(path)

  def avail_fraction(self):
    return (1.0 * self.stat.f_bavail) / self.stat.f_blocks

  def avail_gigs(self):
    return (self.stat.f_frsize  * self.stat.f_bavail) / (2.0 ** 30)

  def report(self):
    return "%s: %.0f GB (%.0f%%) left" % (self.path, self.avail_gigs(),
                                          100 * self.avail_fraction())



if __name__ == '__main__':
  dictConfig(logging_config)
  parser = argparse.ArgumentParser(description='WAMC status')
  parser.add_argument('-n', '--dryrun', dest='dryrun',
          action='store_true', default=False)
  args = parser.parse_args()

  n = Notifier(args)
  try:
    n.maybe_notify()
  except Exception, ex:
    logging.exception(ex)
